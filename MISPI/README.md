

# Лабораторная работа 1: 

1. Методологии разработки ПО. 
2. Унифицированный процесс.
3. Требования и их категоризация. Атрибуты требований.
Язык UML.
4. Прецеденты использования. UseCase-диаграммы - состав, виды связей.

# Лабораторная работа 2: 

## Системы контроля версий - назначение, примеры решений.
## Ревизии и ветки.
## Основные операции над данными в системах контроля версий. Основные команды svn и git.
## Виды конфликтов и способы их решения.

# Трофейные вопросы:

## [Индексация изменений в git и svn](#Индексация-изменений-в-git-и-svn)



## Каким конкретно образом работают коммиты?


`git status -s`, `svn status` - какие файлы менялись, до/после добавления.

Пример вывода:
```
On branch master
Your branch is up to date with 'origin/master'.

Вставить нормальный
```

Об отслеживании изменений в репозитории:

- **Git** делает снимок репо. После каждого изменения в репо чекает изменение каждого файла.
- **SVN** отслеживает не файлы, а их действия над файлами,
то есть смотрит не на внутреннее состояние, а на факт модификации.

`git reset` - отмена индексаций на текущем коммите. 
Можно применить к отдельным файлам для отмены слежки до коммита

## Возвращение к некоторой ревизии в git и svn

SVN:
```
svn checkout -r 5 file:///home/s283904/soc/svn_repos/svnrep/trunk
svn update -r r4
```
Где `-r` номер коммита (ревизии)

Git:
```
git log # смотрим hash коммита
нужно создать отдельную ветку и туда перекочевать
git checkout -b brnch "hash"
```

## `svn commit -a` - значение флага

Такого нет. 

Есть `-A`: еще не добавил, но планируешь добавить этот файл (скорее для себя)

`git commit -a` : все модифицированные файлы добавляются в коммит автоматически

## Контроль merge в git и svn

svn: `ignore-conflict` :)

Конфликты, как правило, нельзя принять механически. Нужно открывать и смотреть. 
Можно вызывать diff, но он обычно не поможет.


## Как перенести правки из одной ветки в другую, сохранить правки, перейти не сохранив правки
  
Перенести правки из одной ветки в другую: 

Сохранить правки: rebase

Перейти не сохранив правки: cherry pick + commit

## Коммит merge должен быть в одном, а не три
  
Нужно объединить на 1 ветке 2 коммита. 
1 ветка файл А с коммитом А, файл Б с коммитом Б. на 2 ветке файл С с коммитом С.
ЧП на 2 ветку 
`git cherry-pick`

## Области видимости в git config - попрактиковаться

- _Global_: Файл `[path]/etc/gitconfig` содержит значения, общие для всех пользователей системы и для всех их репозиториев. 
Если при запуске git config указать параметр --system, то параметры будут читаться и сохраняться именно в этот файл.

- _User_: Файл `~/.gitconfig` или `~/.config/git/config` хранит настройки конкретного пользователя. 
Этот файл используется при указании параметра --global.

- _Repo_: Файл config в каталоге Git (т. е. .git/config) репозитория, который вы используете в данный момент, 
хранит настройки конкретного репозитория. 
Вы можете заставить Git читать и писать в этот файл с помощью параметра --local, но на самом деле это значение по умолчанию.
  

  В `username`, `email`, `password` задаются для юзера, который пушит коммиты.

  `upsteam` для репозитория в случае, если ветки нет в основном репо, то при создании ветки локально, она будет нормально пушиться.


## Git rebase

Х%йня еб%ная. Пидорская


## Получение изменений


`clone`: Копирование удаленного репозитория.

Инициализируется пустой репозиторий. 
Из ветки, которая в конфиге указана, автоматически происходит выгрузка.

`fetch`: Получение обновлений

Команда `git fetch` связывается с удалённым репозиторием и забирает из него все изменения, 
которых у вас пока нет и сохраняет их локально.


`pull`: Обновление существующего репозитория.

Команда `git pull` работает как комбинация команд `git fetch` и `git merge`, т. е. 
Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

В зависимости от того, какая ветка и какой конфиг. Можно настроить стандартную ветку для `pull`. 
Если разработчик работал только в одной ветке и она никому не нужна, то имеет смысл настроить `pull` на `master`, 
чтобы для всех выкачивалась основная ветка. 

`push`: Выгрузка на сервер

Команда `git push` используется для установления связи с удалённым репозиторием, вычисления локальных изменений 
отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. 
Этой команде нужно **право на запись** в репозиторий, поэтому она использует аутентификацию.


## Как внести изменения в merge commit
 
###Как в принципе изменить коммит?

Дока: [Изменение истории проекта](https://git-scm.com/book/ru/v2/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%98%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8)

1. Если вы уже изменили какие-либо файлы, то сначала нужно спрятать изменения. Для этого выполняем команду:
```
git stash
```
2. Посмотрим список коммитов:
```
git log --oneline
```
3. Выполняем команду `git rebase -i` и указываем ей коммит, который мы хотим изменить. 
В данном случае мы хотим изменить третий коммит (относительно `HEAD`).
```
git rebase -i HEAD~3
```
4. Откроется текстовый редактор со списком коммитов. Измените слово `pick` на `edit` (или просто на букву e) у коммита, 
   который вы хотите изменить.

5. Сохраните изменения в файле. Вы снова окажетесь в командной строке.

6. Теперь внесите те изменения, которые вы хотели сделать с файлами. Если вы на первом шаге спрятали эти изменения, то сейчас их можно снова извлечь:
```
git stash pop
```
Или же просто отредактируйте файлы.

7. Добавьте отредактированные файлы в индекс:
```
git add myfile1 myfile2
```
8. Применим наши изменения к коммиту:
```
git commit --amend --no-edit
```
9. Завершим процесс ребейза:
```
git rebase --continue
```
Если все пройдет успешно, то появится сообщение вида:
``` 
Successfully rebased and updated refs/heads/master.
```

### Как изменить несколько коммитов сразу?


1. Предположим, что нам нужно внести изменения сразу в несколько коммитов.
2. Выполняем последовательность действий, описанную выше, но на шаге 4 нужно указать несколько коммитов, которые вы хотите изменить. Для этого нужно изменить слово pick на edit сразу у нескольких коммитов в списке.
3. После сохранения файла (шаг 5) вы переключитесь на первый коммит (который старее), который вы пометили для редактирования.
4. Выполните для него шаги с 6 по 8. После этого вы переключитесь на следующий коммит, который вы пометили для редактирования. И так далее.

`stash`: поместить текущие изменения, которые вы выполнили в файлах, в отдельное хранилище, и вернуть файлы к исходному состоянию.
То есть `git stash` прячет изменения в файлах и сохраняет эти изменения отдельно, чтобы **потом можно было их вернуть**.
- `git stash save "Сообщение для сташа"`: делает то же самое, но можно добавить сообщение
   - Флаг `--include-untracked` или `-u`: спрятать не добавленные в репо файлы
- `git stash apply`: берет самое свежее прятание и применяет его в репо
   - Параметр `git stash apply stash@{1}`: применить конкретное прятание

_Пример_:
Вы выполнили какие-нибудь изменения в файлах и хотите переключиться на другую ветку, но чтобы там не было ваших
текущих изменений. С помощью команды `git stash` можно спрятать эти изменения. Ваши изменения помещаются в
отдельное хранилище — в стек, а вы можете спокойно переключиться на другую ветку.
Всё, что вы прячете с помощью `git stash`, попадает в отдельный список. Затем вы можете извлекать оттуда то, что вы туда
спрятали — ваши «прятанья».

[Подробнее про `git stash`](https://pingvinus.ru/git/1718)



## Как откатить файл до определённой ревизии



# микроКР 1:

- Что имел в виду чел в кастадной модели
- Новвоведения чела на М
- Методология ройса
- rebase
- че делает команда svn
- виды рисков
- что такое svn serve


# Лабораторная работа 3: 

1. Тестирование ПО. Цель тестирования, виды тестирования.
2. Модульное тестирование, основные принципы и используемые подходы.
3. Пакет JUnit, основные API.
4. Системы автоматической сборки. Назначение, принципы работы, примеры систем.
5. Утилита make. Make-файлы, цели и правила.
6. Утилита Ant. Сценарии сборки, цели и команды.

# Лабораторная работа 4: 

1. Мониторинг и профилирование. Основные понятия. Отличия мониторинга от профилирования.
2. Инфраструктура для организации мониторинга и профилирования в составе JDK. JMX.
3. MBeans. Основные понятия. Архитектура фреймворка.
4. Утилита JConsole. Возможности, область применения.
5. Утилита Visual VM. Возможности, область применения.
6. Удалённый мониторинг и профилирование приложений на платформе Java.
