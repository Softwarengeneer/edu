# Вопросы к экзамену МиСПИ 20/21

## 1. ISO/IEC 12207:2010: Жизненный цикл ПО. Группы процессов ЖЦ.

стр. 7

Жизненный цикл – время существования программы от момента замысла, 
до вывода ее из эксплуатации. Все этапы ЖЦ описаны в ISO 

Основные этапы:
- Разработка требований (формулирует заказчик)
- Анализ
- Проектирование
- Разработка и Тестирование
- Внедрение
- Эксплуатация (В процессе эксплуатации происходит поддержка пользователей)
- Вывод из эксплуатации

Группы процессов:
- Согласования (2)
- Орг. обоснования (5)
- Проектов (7)
- Тех. процессов (11)
- Реализация ПС (7)
- Поддержки ПС (8)
- Повторного использования ПС (3)

стр. 8

[wiki](https://ru.wikipedia.org/wiki/ISO/IEC_12207:2008)

## 2. Модели ЖЦ.

стр. 10

![LC_models](img/LC_models.png)


## 3. Водопадная (каскадная) модель.

стр. 12

![Cascade_model](img/Cascade_model.png)
Разработана в 60-х. Критически описана Ройсом в 70-х.

Каскадная модель определяет последовательный переход 
на следующий этап после завершения предыдущего. 
Для этой модели характерна автоматизация отдельных 
несвязанных задач. 

|Достоинства|Недостатки|
|:---|:---|
|Хорошие показатели по срокам разработки и надежности при решении отдельных задач| Неприменимость к большим и сложным проектам из-за невозможности принять изменения требований к системе в течение длительного проектирования|
| | Позднее тестирование|


## 4. Методология Ройса.

стр. 13

**Первый шаг**: 'Дизайн программы’. В нем дизайнеру предлагается спроектировать, определить и создать модели обработки данных и разработать документ: обзор будущей программы  

**Второй шаг**: документирование дизайна, требования к системе, спецификация дизайна, план тестирования, инструкция по использованию.

**Третий шаг**: 'do it twice', тестовая разработка параллельно основному процесса и использование в качестве пилота для подтверждения или опровержения основных спецификаций ПО

**Четвертый шаг**: планирование контроль и мониторинг 

**Пятый шаг**: подключения пользователя на ранних этапах

![Royce_methodology](img/Royce_modal.png)

| Достоинства | Недостатки |
|:---|:---|
| Тестовая разработка параллельно основному процессу | |
| Подключение пользователей | |

## 5. Традиционная V-chart model J.Munson, B.Boehm.

стр. 14

Та же последовательность действий, что и в каскадной модели, 
но каждому уровню разработки свой уровень тестирования.

Модульное, интеграционное и системное тестирование проводятся 
последовательно на основании критериев верификации. Последним 
этапом является приемочное тестирование. Статическое тестирование 
может выполняться на ранней стадии разработки

![V-chart](img/V-chart_modal.png)

|Достоинства|Недостатки|
|:---|:---|
| Тестирование ПО на каждой стадии ||

## 6. Многопроходная модель (Incremental model).

стр. 15

Цикл разделен на более мелкие легко создаваемые модули. Каждый модуль 
проходит через фазы определения требований, проектирования, кодирования, 
внедрения и тестирования. 

Процедура разработки по инкрементной модели предполагает выпуск на первом большом 
этапе продукта в базовой функциональности, а затем уже последовательное 
добавление новых функций, так называемых «инкрементов».

Процесс продолжается до тех пор, пока не будет создана полная система. 
Заказчик может наблюдать за разработкой, вносить изменения, 
которые не сильно увеличат стоимость.

![Incremental-model](img/Incremental-model.png)

|Достоинства|Недостатки|
|:---|:---|
| Изменения заказчика не намного увеличивают стоимость разработки. Модель закладывает не сложную доработку системы| Устаревание архитектуры системы |

## 7. Модель прототипирования (80-е).

стр. 16

Модель позволяет создать прототип программного продукта до или в течение 
этапа составления требований к программному продукту. 

Потенциальные пользователи работают с этим прототипом, определяя его сильные 
и слабые стороны, о результатах сообщают разработчикам программного продукта. 

Если прототип не подходит, то разработка начинается заново. 

Таким образом, обеспечивается обратная связь между 
пользователями и разработчиками, которая используется для изменения или корректировки спецификации требований к программному продукту

![Prototype_model](img/Prototype_model.png)

Жизненный цикл разработки программного продукта начинается с **разработки плана проекта**, 
затем выполняется **быстрый анализ**, после чего **создаются база данных**, 
**пользовательский интерфейс** и выполняется **разработка необходимых функций**. 

В результате этой работы получается документ, содержащий частичную 
спецификацию требований к программному продукту. После этого определяются 
проблемы, над устранением которых совместно работают пользователи и 
разработчики. Этот процесс продолжается, пока пользователи не станут довольны.


|Достоинства|Недостатки|
|:---|:---|
| Быстрая обратная связь ||
| Программный продукт точнее отвечает запросам пользователей ||

## 8. RAD методология. 80-е

стр. 18

**R**apid **A**pplication **D**evelopment model или быстрая разработка приложений

Разновидность _инкрементной модели_. Пользователь принимает 
непосредственное участие в процессе разработки.

При помощи интерфейса, пользователь способен создавать простейшие функции. 
В RAD-модели компоненты или функции разрабатываются несколькими 
высококвалифицированными командами параллельно, будто несколько мини-проектов.

Временные рамки одного цикла жестко **ограничены**.

Созданные модули затем интегрируются в один рабочий прототип. 
Синергия позволяет очень быстро предоставить клиенту для обозрения 
что-то рабочее с целью получения обратной связи и внесения изменений.

![RAD_model](img/RAD_model.png)

Модель быстрой разработки приложений включает следующие фазы:
- Бизнес-моделирование
- Моделирование данных
- Моделирование процесса
- Сборка приложения
- Тестирование

|Достоинства|Недостатки|
|:---|:---|
| Обратная связь от пользователей ||
| ||

## 9. Спиральная модель.

стр. 17

Спиральная модель = проектирование + постадийное прототипирование 

с целью сочетания преимуществ восходящей и нисходящей концепции. 
Данный подход может оказаться довольно затратным в применении. 

В спиральной модели особое внимание уделяется управлению рисками. 
Контроль рисков, в свою очередь, требует проведения специфического 
анализа на каждой итерации. Изменения – неотъемлемая часть разработки.

![Spiral_model](img/Spiral_model.png)

|Достоинства|Недостатки|
|:---|:---|
| Изменения – неотъемлемая часть разработки | Разработка может оказаться затратной|
| Особое внимание уделяется управлению рисками | Не подходит для маленьких проектов |

10. UML Диаграммы: Структурные и поведенческие.
11. UML: Use-case модель.
12. UML: Диаграмма классов.
13. UML: Диаграмма последовательностей
14. UML: Диаграмма размещения
15. *UP методологии (90-е). RUP: основы процесса.
16. RUP: Фаза «Начало».
17. RUP: Фаза «Проектирование».
18. RUP: Фаза «Построение».
19. RUP: Фаза «Внедрение».
20. Манифест Agile (2001).
21. Scrum.
22. Disciplined Agile 2.X (2013).
23. Требования. Иерархия требований.
24. Свойства и типы требований (FURPS+).
25. Формулирование требований. Функциональные требования.
26. Требования к удобству использования и надежности.
27. Требования к производительности и поддерживаемости.
28. Атрибуты требований.
29. Описание прецедента.
30. Риски. Типы Рисков.
31. Управления рисками. Деятельности, связанные с оценкой.
32. Управления рисками. Деятельности, связанные контролем и управлением.
33. Изменение. Общая модель управления изменениями.
34. Системы контроля версий. Одновременная модификация файлов.
35. Subversion. Архитектура системы и репозиторий.
36. Subversion: Основной цикл разработчика. Команды.
37. Subversion: Конфликты. Слияние изменений.
38. GIT: Архитектура и команды.
39. GIT: Организация ветвей репозитория.
40. GIT: Плагин git-flow.
41. Системы автоматической сборки: предпосылки появления
42. Системы сборки: Make и Makefile.
43. Системы сборки: Ant. Команды Ant.
44. Системы сборки: Ant-ivy.
45. Системы сборки: Maven. POM. Репозитории и зависимости.
46. Maven: Структура проекта. GAV.
47. Maven: Зависимости. Жизненный цикл сборки. Плагины.
48. Системы сборки: Maven. POM. Репозитории и зависимости.
49. Системы сборки: GNU autotools. Создание конфигурации проекта.
50. Системы сборки: GNU autotools. Конфигурация и сборка проекта.
51. Сервера сборки/непрерывной интеграции.
52. Основные понятия тестирования. Цели тестирования.
53. Понятие полного тестового покрытия и его достижимости. Пример.
54. Статическое и динамическое тестирование.
55. Автоматизация тестов и ручное тестирование.
56. Источники данных для тестирования. Роли и деятельности в тестировании.
57. Понятие тестового случая и сценария.
58. Выбор тестового покрытия и количества тестов. Анализ эквивалентности.
59. Модульное тестирование. Junit 4.
60. Интеграционное тестирование. Стратегии интеграции.
61. Функциональное тестирование. Selenium.
62. Техники статического тестирования. Статический анализ кода.
63. Тестирование системы в целом. Системное тестирование. Тестирование
производительности.
64. Тестирование системы в целом. Альфа- и бета-тестирование.
65. Аспекты быстродействия системы. Влияние средств измерения на результаты.
66. Ключевые характеристики производительности.
67. Нисходящий метод поиска узких мест.
68. Пирамида памяти и ее влияние на производительность.
69. Мониторинг производительности: процессы.
70. Мониторинг производительности: виртуальная память.
71. Мониторинг производительности: буферизированный файловый ввод-вывод.
72. Мониторинг производительности: Windows и Linux.
73. Системный анализ Linux "за 60 секунд".
74. Создание тестовой нагрузки и нагрузчики.
75. Профилирование приложений. Основные подходы.
76. Компромиссы (trade-offs) в производительности.
77. Рецепты повышения производительности при высоком %SYS.
78. Рецепты повышения производительности при высоком %IO wait.
79. Рецепты повышения производительности при высоком %Idle.
80. Рецепты повышения производительности при высоком %User.
