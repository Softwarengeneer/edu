# Вопросы к экзамену МиСПИ 20/21

## 1. ISO/IEC 12207:2010: Жизненный цикл ПО. Группы процессов ЖЦ.

стр. 7

Жизненный цикл – время существования программы от момента замысла, 
до вывода ее из эксплуатации. Все этапы ЖЦ описаны в ISO 

Основные этапы:
- Разработка требований (формулирует заказчик)
- Анализ
- Проектирование
- Разработка и Тестирование
- Внедрение
- Эксплуатация (В процессе эксплуатации происходит поддержка пользователей)
- Вывод из эксплуатации

Группы процессов:
- Согласования (2)
- Орг. обоснования (5)
- Проектов (7)
- Тех. процессов (11)
- Реализация ПС (7)
- Поддержки ПС (8)
- Повторного использования ПС (3)

стр. 8

[wiki](https://ru.wikipedia.org/wiki/ISO/IEC_12207:2008)

## 2. Модели ЖЦ.

стр. 10

![LC_models](img/LC_models.png)


## 3. Водопадная (каскадная) модель.

стр. 12

![Cascade_model](img/Cascade_model.png)
Разработана в 60-х. Критически описана Ройсом в 70-х.

Каскадная модель определяет последовательный переход 
на следующий этап после завершения предыдущего. 
Для этой модели характерна автоматизация отдельных 
несвязанных задач. 

|Достоинства|Недостатки|
|:---|:---|
|Хорошие показатели по срокам разработки и надежности при решении отдельных задач| Неприменимость к большим и сложным проектам из-за невозможности принять изменения требований к системе в течение длительного проектирования|
| | Позднее тестирование|


## 4. Методология Ройса.

стр. 13

**Первый шаг**: 'Дизайн программы’. В нем дизайнеру предлагается спроектировать, определить и создать модели обработки данных и разработать документ: обзор будущей программы  

**Второй шаг**: документирование дизайна, требования к системе, спецификация дизайна, план тестирования, инструкция по использованию.

**Третий шаг**: 'do it twice', тестовая разработка параллельно основному процесса и использование в качестве пилота для подтверждения или опровержения основных спецификаций ПО

**Четвертый шаг**: планирование контроль и мониторинг 

**Пятый шаг**: подключения пользователя на ранних этапах

![Royce_methodology](img/Royce_modal.png)

| Достоинства | Недостатки |
|:---|:---|
| Тестовая разработка параллельно основному процессу | |
| Подключение пользователей | |

## 5. Традиционная V-chart model J.Munson, B.Boehm.

стр. 14

Та же последовательность действий, что и в каскадной модели, 
но каждому уровню разработки свой уровень тестирования.

Модульное, интеграционное и системное тестирование проводятся 
последовательно на основании критериев верификации. Последним 
этапом является приемочное тестирование. Статическое тестирование 
может выполняться на ранней стадии разработки

![V-chart](img/V-chart_modal.png)

|Достоинства|Недостатки|
|:---|:---|
| Тестирование ПО на каждой стадии ||

## 6. Многопроходная модель (Incremental model).

стр. 15

Цикл разделен на более мелкие легко создаваемые модули. Каждый модуль 
проходит через фазы определения требований, проектирования, кодирования, 
внедрения и тестирования. 

Процедура разработки по инкрементной модели предполагает выпуск на первом большом 
этапе продукта в базовой функциональности, а затем уже последовательное 
добавление новых функций, так называемых «инкрементов».

Процесс продолжается до тех пор, пока не будет создана полная система. 
Заказчик может наблюдать за разработкой, вносить изменения, 
которые не сильно увеличат стоимость.

![Incremental-model](img/Incremental-model.png)

|Достоинства|Недостатки|
|:---|:---|
| Изменения заказчика не намного увеличивают стоимость разработки. Модель закладывает не сложную доработку системы| Устаревание архитектуры системы |

## 7. Модель прототипирования (80-е).

стр. 16

Модель позволяет создать прототип программного продукта до или в течение 
этапа составления требований к программному продукту. 

Потенциальные пользователи работают с этим прототипом, определяя его сильные 
и слабые стороны, о результатах сообщают разработчикам программного продукта. 

Если прототип не подходит, то разработка начинается заново. 

Таким образом, обеспечивается обратная связь между 
пользователями и разработчиками, которая используется для изменения или корректировки спецификации требований к программному продукту

![Prototype_model](img/Prototype_model.png)

Жизненный цикл разработки программного продукта начинается с **разработки плана проекта**, 
затем выполняется **быстрый анализ**, после чего **создаются база данных**, 
**пользовательский интерфейс** и выполняется **разработка необходимых функций**. 

В результате этой работы получается документ, содержащий частичную 
спецификацию требований к программному продукту. После этого определяются 
проблемы, над устранением которых совместно работают пользователи и 
разработчики. Этот процесс продолжается, пока пользователи не станут довольны.


|Достоинства|Недостатки|
|:---|:---|
| Быстрая обратная связь ||
| Программный продукт точнее отвечает запросам пользователей ||

## 8. RAD методология. 80-е

стр. 18

**R**apid **A**pplication **D**evelopment model или быстрая разработка приложений

Разновидность _инкрементной модели_. Пользователь принимает 
непосредственное участие в процессе разработки.

При помощи интерфейса, пользователь способен создавать простейшие функции. 
В RAD-модели компоненты или функции разрабатываются несколькими 
высококвалифицированными командами параллельно, будто несколько мини-проектов.

Временные рамки одного цикла жестко **ограничены**.

Созданные модули затем интегрируются в один рабочий прототип. 
Синергия позволяет очень быстро предоставить клиенту для обозрения 
что-то рабочее с целью получения обратной связи и внесения изменений.

![RAD_model](img/RAD_model.png)

Модель быстрой разработки приложений включает следующие фазы:
- Бизнес-моделирование
- Моделирование данных
- Моделирование процесса
- Сборка приложения
- Тестирование

|Достоинства|Недостатки|
|:---|:---|
| Обратная связь от пользователей ||
| ||

## 9. Спиральная модель.

стр. 17

Спиральная модель = проектирование + постадийное прототипирование 

с целью сочетания преимуществ восходящей и нисходящей концепции. 
Данный подход может оказаться довольно затратным в применении. 

В спиральной модели особое внимание уделяется управлению рисками. 
Контроль рисков, в свою очередь, требует проведения специфического 
анализа на каждой итерации. Изменения – неотъемлемая часть разработки.

![Spiral_model](img/Spiral_model.png)

|Достоинства|Недостатки|
|:---|:---|
| Изменения – неотъемлемая часть разработки | Разработка может оказаться затратной|
| Особое внимание уделяется управлению рисками | Не подходит для маленьких проектов |

## 10. UML Диаграммы: Структурные и поведенческие.

Основное назначение UML - графическое представление различных аспектов
разработки ПО.

![uml_diagrams](img/uml_diagrams.png)
стр. 34 [UML 2]

### Структурные диаграммы 
Эти диаграммы используются для демонстрации статической структуры элементов 
в системе. Они могут изображать **архитектурную организацию системы**, **ее 
физические элементы**, **текущую конфигурацию**, а также **специфические элементы** 
предметной области.

### Поведенческие диаграммы

События, происходящие в системах программного обеспечения, 
являются динамическими: 
- объекты создаются и уничтожаются, 
- объекты передают сообщения другим объектам и системам, 
- внешние события активизируют операции над определенными объектами.  

## 11. UML: Use-case модель.
    
Это диаграмма динамического поведения в UML, которая моделирует 
функциональность системы с использованием участников, прецедентов и 
других важнейших объектов. 

Акторы (actors) — это люди или организации, которые 
работают под определенными ролями внутри системы. 

`Отношение включения` указывает на то, что поведение одного прецедента 
включается в некоторой точке в другой прецедент в качестве составного 
компонента. 

`Отношение расширения` отражает возможное присоединение одного 
варианта использования к другому в некоторой точке. 

![uml_morphysms](img/uml_morphysms.png)
стр. 33 [UML 2]
## 12. UML: Диаграмма классов.
    

## 13. UML: Диаграмма последовательностей
    

## 14. UML: Диаграмма размещения
    

## 15. *UP методологии (90-е). RUP: основы процесса.
    

## 16. RUP: Фаза «Начало».

стр. 22
    
- Определение границ проекта
- Описание основных сценариев использования системы
- Разработка технологических решений
- Оценка рисков
- Подготовка окружения

## 17. RUP: Фаза «Проектирование».
    

## 18. RUP: Фаза «Построение».


## 19. RUP: Фаза «Внедрение».


20. Манифест Agile (2001).
21. Scrum.
22. Disciplined Agile 2.X (2013).
23. Требования. Иерархия требований.
24. Свойства и типы требований (FURPS+).
25. Формулирование требований. Функциональные требования.
26. Требования к удобству использования и надежности.
27. Требования к производительности и поддерживаемости.
28. Атрибуты требований.
29. Описание прецедента.
30. Риски. Типы Рисков.
31. Управления рисками. Деятельности, связанные с оценкой.
32. Управления рисками. Деятельности, связанные контролем и управлением.
33. Изменение. Общая модель управления изменениями.
34. Системы контроля версий. Одновременная модификация файлов.
35. Subversion. Архитектура системы и репозиторий.
36. Subversion: Основной цикл разработчика. Команды.
37. Subversion: Конфликты. Слияние изменений.
38. GIT: Архитектура и команды.
39. GIT: Организация ветвей репозитория.
40. GIT: Плагин git-flow.


41. Системы автоматической сборки: предпосылки появления
1) Рутинный процесс сборки
2) Отличия архитектуры информационных систем
3) Медленная сборка

Если брать параллельные процессы компиляции, то возникает проблема доступа сборочных узлов к общим исходным 
кодам проекта

Вышеперечисленные причины и привели к появлению разнообразных систем сборки

42. Системы сборки: Make и Makefile.

Make - система сборки, появившаяся впервые в Unix-системах, существует и по сей день.

Является императивной(условно) системой сборки. Исходный код сборки располагается в Makefile, который
в свою очередь располагается в корневой директории проекта. Далее в корневой директории прописывается
команда "make" и происходит сборка проекта. По умолчанию основной направленностью maka являются "file targets". 
Чтобы сказать Make, что мы хотим работать не с файлами, а с наименованием цели, используем слово "PHONY".
Основная цель - all. Пример цели:

all:
    gcc -o main main.c
    
43. Системы сборки: Ant. Команды Ant.
Apache Ant представляет собой императивную систему сборки, использующую в качестве основного файла build.xml.
Разрабатывалась для использования в Java-проектах. Файл состоит из target, в которых описана определенная
последовательность действий для достижения поставленной цели. Пример простого build.xml.

<myxml>

    <project name="MyProject" default="dist" basedir=".">
      <property name="src" location="src"/>
      <property name="build" location="build"/>
    
      <target name="init">
        <mkdir dir="${build}"/>
      </target>
    
      <target name="compile" depends="init">
        <javac srcdir="${src}" destdir="${build}"/>
      </target>
    </project>  
<myxml>

44. Системы сборки: Ant-ivy.
Apache Ivy - транзитивный менеджер пакетов, который использутся совместно с Apache Ant.
Пакет скачивает из Maven-репозитория(определение см ниже). Для конфигурации использует файлы 
ivysetting.xml и ivy.xml.

В головной build.xml подключиется при помощи:
<myxml>

    <project name="MyProject" xmlns:ivy="antlib:org.apache.ivy.ant" default="dist" basedir=".">
        <target name="resolve">
            <ivy:retrieve/>
        </target>
        
<myxml>

Пример зависимости:

<myxml>

    <ivy-module version="2.0">
    <info organisation="org.apache" module="hello-ivy"/>
    <dependencies>
        <dependency org="jakarta.annotation" name="jakarta.annotation-api" rev="1.3.5" />
    </dependencies>
    </ivy-module>
    
<myxml>

45. Системы сборки: Maven. POM. Репозитории и зависимости.
Apache Maven - одна из самых популярных систем сборки для Java-проектов на 
сегодняшний день. Использует декларативный подход. Основным файлом выступаем POM,
(Project Object Model)(основной файл - pom.xml)

<myxml>

    <project xmlns="http://maven.apache.org/POM/4.0.0"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0   http://maven.apache.org/xsd/maven-4.0.0.xsd">    
      
      <modelVersion>4.0.0</modelVersion>  
      <groupId>com.javatpoint.application1</groupId>  
      <artifactId>my-app</artifactId>  
      <version>1</version> 
       
    </project>  

<myxml>
В POM указываются имя, версия и тип программы, местоположение исходных кодов проекта
зависимости, плагины, альтернативные конфигурации проекта

Репозитории и зависимости.

![](img/cycle.png)

46. Maven: Структура проекта. GAV.

![](img/struct.png)

В Maven существует система каталогов по умолчанию (src/main/java - исходные коды проекта)
(src/main/resources - дополнительные файлы проекта, .proprties файлы)

После работы готовые файлы кладутся в директорию target

GAV.

В Maven все зависимости описываются в GAV-синтаксисе, который представляет собой:
groupId:artifactId:version. Так описывается любая внешняя зависимость. Данные зависимости
скачиваются из интернета, поэтому если это не нужно, надо запретить в явном виде.

<myxml>

    <project>
      <modelVersion>4.0.0</modelVersion>
     
      <groupId>com.mycompany.app</groupId>
      <artifactId>my-app</artifactId>
      <version>1</version>
    </project>

</myxml>

47. Maven: Зависимости. Жизненный цикл сборки. Плагины.

Зависимости см пункт выше

![](img/lifecycle.png)

![](img/plugin.png)

48. Системы сборки: Maven. POM. Репозитории и зависимости.

СМ. 45-47

49. Системы сборки: GNU autotools. Создание конфигурации проекта.

Autotools, или система сборки GNU,— это набор программных средств, предназначенных для поддержки переносимости исходного кода программ между UNIX-подобными системами.

Требуемая последовательность команд для запуска: ./configure && make && make install

![](img/tools.png)

50. Системы сборки: GNU autotools. Конфигурация и сборка проекта.

![](img/confs.png)

51. Сервера сборки/непрерывной интеграции.

![](img/serv.png)

52. Основные понятия тестирования. Цели тестирования.
53. Понятие полного тестового покрытия и его достижимости. Пример.
54. Статическое и динамическое тестирование.
55. Автоматизация тестов и ручное тестирование.
56. Источники данных для тестирования. Роли и деятельности в тестировании.
57. Понятие тестового случая и сценария.
58. Выбор тестового покрытия и количества тестов. Анализ эквивалентности.
59. Модульное тестирование. Junit 4.
60. Интеграционное тестирование. Стратегии интеграции.
61. Функциональное тестирование. Selenium.
62. Техники статического тестирования. Статический анализ кода.
63. Тестирование системы в целом. Системное тестирование. Тестирование производительности.
64. Тестирование системы в целом. Альфа- и бета-тестирование.
65. Аспекты быстродействия системы. Влияние средств измерения на результаты.
66. Ключевые характеристики производительности.
67. Нисходящий метод поиска узких мест.
68. Пирамида памяти и ее влияние на производительность.
69. Мониторинг производительности: процессы.
70. Мониторинг производительности: виртуальная память.
71. Мониторинг производительности: буферизированный файловый ввод-вывод.
72. Мониторинг производительности: Windows и Linux.
73. Системный анализ Linux "за 60 секунд".
74. Создание тестовой нагрузки и нагрузчики.
75. Профилирование приложений. Основные подходы.
76. Компромиссы (trade-offs) в производительности.
77. Рецепты повышения производительности при высоком %SYS.
78. Рецепты повышения производительности при высоком %IO wait.
79. Рецепты повышения производительности при высоком %Idle.
80. Рецепты повышения производительности при высоком %User.
